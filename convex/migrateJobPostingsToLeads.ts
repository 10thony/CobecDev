import { action, internalMutation, internalQuery } from "./_generated/server";
import { v } from "convex/values";
import { api, internal } from "./_generated/api";
import { Doc, Id } from "./_generated/dataModel";

/**
 * Migration to consolidate jobpostings table into leads table
 * This migration automatically runs when called and ports all job posting data to leads
 */

// Internal query to get all job postings (must be in non-Node.js file)
export const getAllJobPostings = internalQuery({
  args: {},
  handler: async (ctx) => {
    // Query jobpostings table directly
    return await ctx.db.query("jobpostings").collect();
  },
});

// Internal mutation to insert a lead from a job posting
export const insertLeadFromJobPosting = internalMutation({
  args: {
    jobPosting: v.any(),
  },
  handler: async (ctx, { jobPosting }) => {
    const now = Date.now();
    
    // Map job posting fields to leads format
    const leadData = {
      // Map core fields
      opportunityType: "Job Posting",
      opportunityTitle: jobPosting.jobTitle || "Untitled Job",
      contractID: undefined,
      
      // Map issuing body (department becomes name, location becomes level approximation)
      issuingBody: {
        name: jobPosting.department || "Unknown Department",
        level: "Unknown", // Job postings don't have a clear level, default to Unknown
      },
      
      // Map location - try to parse the location string
      location: {
        city: undefined,
        county: undefined,
        region: jobPosting.location || "Unknown", // Use location string as region
      },
      
      // Map status - use closeDate or applicationDeadline to determine status
      status: jobPosting.closeDate || jobPosting.applicationDeadline 
        ? "Open for Bidding" 
        : "Active",
      
      estimatedValueUSD: undefined,
      
      // Map dates
      keyDates: {
        publishedDate: jobPosting.openDate || undefined,
        bidDeadline: jobPosting.closeDate || jobPosting.applicationDeadline || undefined,
        projectedStartDate: undefined,
      },
      
      // Map source
      source: {
        documentName: jobPosting.jobTitle || "Job Posting",
        url: jobPosting.jobLink || "",
      },
      
      // Map contacts - try to parse contactInfo
      contacts: jobPosting.contactInfo ? [{
        name: undefined,
        title: "Contact",
        email: undefined,
        phone: undefined,
        url: undefined,
      }] : [],
      
      // Map summary
      summary: jobPosting.jobSummary || jobPosting.duties || "No summary available",
      
      verificationStatus: undefined,
      category: jobPosting.jobType || undefined,
      subcategory: undefined,
      isActive: true,
      lastChecked: now,
      
      // Map search and embedding fields
      searchableText: jobPosting.searchableText || undefined,
      completeSearchableText: jobPosting.completeSearchableText || undefined,
      extractedSkills: jobPosting.extractedSkills || undefined,
      embedding: jobPosting.embedding || undefined,
      embeddingModel: jobPosting.embeddingModel || undefined,
      embeddingGeneratedAt: jobPosting.embeddingGeneratedAt || undefined,
      
      // Map all job posting specific fields
      salary: jobPosting.salary || undefined,
      jobType: jobPosting.jobType || undefined,
      duties: jobPosting.duties || undefined,
      requirements: jobPosting.requirements || undefined,
      qualifications: jobPosting.qualifications || undefined,
      education: jobPosting.education || undefined,
      howToApply: jobPosting.howToApply || undefined,
      additionalInformation: jobPosting.additionalInformation || undefined,
      seriesGrade: jobPosting.seriesGrade || undefined,
      travelRequired: jobPosting.travelRequired || undefined,
      workSchedule: jobPosting.workSchedule || undefined,
      securityClearance: jobPosting.securityClearance || undefined,
      experienceRequired: jobPosting.experienceRequired || undefined,
      educationRequired: jobPosting.educationRequired || undefined,
      applicationDeadline: jobPosting.applicationDeadline || undefined,
      contactInfo: jobPosting.contactInfo || undefined,
      
      // Migration compatibility fields
      // Note: _id is auto-generated by Convex, so we don't set it here
      _index: jobPosting._index || undefined,
      
      // Map metadata
      metadata: {
        sourceFile: jobPosting.metadata?.sourceFile || undefined,
        importedAt: jobPosting.metadata?.importedAt || jobPosting.createdAt || now,
        dataType: "job_posting",
        originalIndex: jobPosting.metadata?.originalIndex || jobPosting._index || undefined,
        embeddingModel: jobPosting.metadata?.embeddingModel || jobPosting.embeddingModel || undefined,
        parsedAt: jobPosting.metadata?.parsedAt || undefined,
        processedAt: jobPosting.metadata?.processedAt || undefined,
      },
      
      // Store the original job posting Convex ID in adHoc for reference
      adHoc: jobPosting._id ? {
        originalJobPostingId: jobPosting._id,
      } : undefined,
      createdAt: jobPosting.createdAt || now,
      updatedAt: jobPosting.updatedAt || now,
    };
    
    return await ctx.db.insert("leads", leadData);
  },
});

/**
 * Main migration action - ports all job postings to leads
 * This should be run automatically or manually after schema deployment
 */
export const migrateJobPostingsToLeads = action({
  args: {
    batchSize: v.optional(v.number()),
    dryRun: v.optional(v.boolean()),
  },
  handler: async (ctx, { batchSize = 100, dryRun = false }): Promise<{
    success: boolean;
    migrated: number;
    errors: number;
    total?: number;
    dryRun?: boolean;
    wouldMigrate?: number;
    errorDetails?: string[];
    error?: string;
    message: string;
  }> => {
    console.log("Starting migration of jobpostings to leads...");
    
    try {
      // Get all job postings using internal query
      const allJobPostings: Doc<"jobpostings">[] = await ctx.runQuery(internal.migrateJobPostingsToLeads.getAllJobPostings);
      
      if (!allJobPostings || allJobPostings.length === 0) {
        console.log("No job postings found to migrate.");
        return {
          success: true,
          migrated: 0,
          errors: 0,
          message: "No job postings found to migrate.",
        };
      }
      
      console.log(`Found ${allJobPostings.length} job postings to migrate.`);
      
      if (dryRun) {
        console.log("DRY RUN: Would migrate", allJobPostings.length, "job postings");
        return {
          success: true,
          migrated: 0,
          errors: 0,
          dryRun: true,
          wouldMigrate: allJobPostings.length,
          message: `DRY RUN: Would migrate ${allJobPostings.length} job postings`,
        };
      }
      
      let migrated = 0;
      let errors = 0;
      const errorDetails: string[] = [];
      
      // Process in batches
      for (let i = 0; i < allJobPostings.length; i += batchSize) {
        const batch = allJobPostings.slice(i, i + batchSize);
        console.log(`Processing batch ${Math.floor(i / batchSize) + 1} (${batch.length} items)...`);
        
        for (const jobPosting of batch) {
          try {
            await ctx.runMutation(internal.migrateJobPostingsToLeads.insertLeadFromJobPosting, {
              jobPosting: jobPosting as any,
            });
            migrated++;
          } catch (error) {
            errors++;
            const errorMsg = `Error migrating job posting ${jobPosting._id || 'unknown'}: ${error instanceof Error ? error.message : String(error)}`;
            console.error(errorMsg);
            errorDetails.push(errorMsg);
          }
        }
      }
      
      console.log(`Migration complete. Migrated: ${migrated}, Errors: ${errors}`);
      
      return {
        success: errors === 0,
        migrated,
        errors,
        total: allJobPostings.length,
        errorDetails: errorDetails.length > 0 ? errorDetails : undefined,
        message: `Migration complete. Migrated ${migrated} of ${allJobPostings.length} job postings.`,
      };
    } catch (error) {
      console.error("Migration failed:", error);
      return {
        success: false,
        migrated: 0,
        errors: 1,
        error: error instanceof Error ? error.message : String(error),
        message: `Migration failed: ${error instanceof Error ? error.message : String(error)}`,
      };
    }
  },
});

/**
 * Automatic migration that runs on deployment
 * This can be called automatically via a scheduled function or manually
 */
export const runAutomaticMigration = action({
  args: {},
  handler: async (ctx): Promise<{
    success: boolean;
    migrated: number;
    errors: number;
    total?: number;
    dryRun?: boolean;
    wouldMigrate?: number;
    errorDetails?: string[];
    error?: string;
    message: string;
  }> => {
    console.log("Running automatic migration of jobpostings to leads...");
    
    // Run the migration
    // Note: This migration is not idempotent - it will create duplicates if run multiple times
    // In production, you might want to add a check to see if migration was already completed
    return await ctx.runAction(api.migrateJobPostingsToLeads.migrateJobPostingsToLeads, {
      batchSize: 100,
      dryRun: false,
    });
  },
});
